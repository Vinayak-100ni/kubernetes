# 1Ô∏è‚É£ **What is Ingress?**

Ingress is a **Kubernetes API object** that manages **external access** to services inside the cluster, typically using **HTTP / HTTPS**.

It allows you to:

* Expose multiple services using **one external IP**
* Route traffic based on **hostnames** or **paths**
* Terminate **TLS/SSL** at the edge
* Apply central **routing rules** and **security policies**

üëâ Without Ingress, you would need **one LoadBalancer per service**, increasing cost and complexity.

---

# 2Ô∏è‚É£ **Why Do We Need Ingress?**

### üîπ Without Ingress

* Every service <NodePort> or <LoadBalancer> costs money
* Hard to manage routing for many microservices
* TLS/SSL must be configured separately for each service
* No central request control or monitoring

### üîπ With Ingress

* ‚úî One single LoadBalancer for all apps
* ‚úî Host/path-based routing
* ‚úî TLS termination at one place
* ‚úî URL rewrites, redirects, rate limits
* ‚úî Integrates with cert-manager for auto SSL
* ‚úî Can apply WAF/security/logging at a single point

---

# 3Ô∏è‚É£ **Ingress Components**

Understanding components will help you debug and design better:

---

## üß± **1. Ingress Resource**

YAML object containing routing rules.

Example:

```yaml
kind: Ingress
metadata:
  name: myapp-ingress
spec:
  rules:
    - host: app.example.com
      http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: myapp-service
              port:
                number: 80
```

---

## üß± **2. Ingress Controller (Mandatory)**

Ingress **does not work alone**.

You must install an **Ingress Controller**.

Examples:

* **Nginx Ingress Controller** (most common)
* **Traefik**
* **HAProxy**
* **Istio Gateway** (service mesh)
* **AWS ALB Ingress Controller**
* **GKE Ingress Controller**

The controller watches Ingress objects and configures loadbalancer rules.

---

## üß± **3. LoadBalancer**

* Created by the Ingress Controller
* Accepts external traffic
* Sends it to Nginx ‚Üí routes ‚Üí service ‚Üí pod

---

## üß± **4. Backend Kubernetes Services**

Ingress forwards to:

* ClusterIP services only

Example:

```
Internet ‚Üí LB ‚Üí Ingress Controller ‚Üí Ingress Rules ‚Üí Service ‚Üí Pod
```

---

# 4Ô∏è‚É£ **How Ingress Works (Flow)**

```
Client Browser ‚Üí Ingress LoadBalancer ‚Üí Ingress Controller (NGINX) 
‚Üí Ingress rules ‚Üí K8s service ‚Üí Pod
```

### Detailed Flow:

1Ô∏è‚É£ User hits `https://app.example.com`
2Ô∏è‚É£ LoadBalancer receives the request
3Ô∏è‚É£ Sends to Nginx Ingress Controller
4Ô∏è‚É£ Controller checks Ingress rules
5Ô∏è‚É£ Matches hostname/path
6Ô∏è‚É£ Forwards traffic to service
7Ô∏è‚É£ Request goes to the appropriate pod

---

# 5Ô∏è‚É£ **How to Setup NGINX Ingress Controller (Production Grade)**

You can install using **Helm** (recommended) or manifest.

---

## üõ† **Install Nginx Ingress Controller (Helm)**

### Step 1 ‚Äî Add Helm repo

```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
```

### Step 2 ‚Äî Install controller

```bash
helm install ingress-nginx ingress-nginx/ingress-nginx -n ingress-nginx --create-namespace
```

### Step 3 ‚Äî Verify installation

```bash
kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx
```

Expected:

* A **LoadBalancer service**
* Nginx controller pods running

---

# 6Ô∏è‚É£ **Create Ingress Example (Path-Based Routing)**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: mysite.com
    http:
      paths:
      - path: /app1
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
      - path: /app2
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80
```

---

# 7Ô∏è‚É£ **TLS/HTTPS with Ingress (Auto SSL)**

Requires cert-manager.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: secure-app
spec:
  tls:
  - hosts:
    - secure.example.com
    secretName: tls-secret
  rules:
    - host: secure.example.com
      http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: secure-service
              port:
                number: 80
```

---

# 8Ô∏è‚É£ **How Ingress Works With Cert-Manager (Auto SSL)**

```
Ingress ‚Üí Certificate ‚Üí Issuer ‚Üí Let's Encrypt ‚Üí TLS Secret Auto Generated
```

---

# 9Ô∏è‚É£ **Ingress in Production ‚Äî Best Practices**

| Feature       | Recommendation                      |
| ------------- | ----------------------------------- |
| Controller    | Nginx or Cloud Provider Ingress     |
| SSL           | Use Cert-Manager with Let‚Äôs Encrypt |
| Load Balancer | Use managed LB                      |
| Routing       | Host-based for microservices        |
| Security      | Enable WAF rules + rate limits      |
| Monitoring    | Use Prometheus + Grafana            |

---

# üîü **When to Use Ingress vs. Service vs. LoadBalancer**

| Need                                                     | Use             |
| -------------------------------------------------------- | --------------- |
| Internal service communication                           | ClusterIP       |
| Expose service without routing rules                     | LoadBalancer    |
| Expose many services using one entrypoint + HTTP routing | Ingress         |
| Service mesh features (mTLS, retries, traffic shaping)   | Istio / Linkerd |

---

# 1Ô∏è‚É£1Ô∏è‚É£ **Ingress vs Gateway API (Future of K8s)**

Gateway API is replacing Ingress in long term.

Ingress = old
Gateway API = modern, flexible, mesh-compatible, multi-tenant

---

# üéØ **Summary**

**Ingress is essential** for:

* Efficient routing
* Cost reduction
* TLS management
* Clean architecture
* Centralized control & security

You need:

* Ingress Resource
* Ingress Controller
* LoadBalancer
* Backend services
